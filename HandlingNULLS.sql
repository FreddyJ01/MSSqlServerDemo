-- Handling Nulls in SQL Server

USE DemoDB;
GO

-- Creating a new table

CREATE TABLE CLIENTS1
(
    FIRST_NAME VARCHAR(50),
    MIDDLE_NAME VARCHAR(50),
    LAST_NAME VARCHAR(50)
);

-- Inserting 2 rows. Both rows contain a null value for MIDDLE_NAME:

INSERT INTO CLIENTS1 (FIRST_NAME, MIDDLE_NAME, LAST_NAME) VALUES ('Kevin', NULL, 'Osten');
INSERT INTO CLIENTS1 (FIRST_NAME, LAST_NAME) VALUES ('Anna', 'Victor');

SELECT *
FROM CLIENTS1;

-- Nulls in math operations.

CREATE TABLE EMPLOYEES0
(
    EMP_ID INT,
    EMP_LAST_NAME VARCHAR(100),
    SALARY DECIMAL(12,2),
    BONUS DECIMAL(12,2)
);

INSERT INTO EMPLOYEES0 (EMP_ID, EMP_LAST_NAME, SALARY, BONUS) VALUES (1, 'Jones', 6000, 800);
INSERT INTO EMPLOYEES0 (EMP_ID, EMP_LAST_NAME, SALARY, BONUS) VALUES (2, 'Richardson', 65000, null);

SELECT *
FROM EMPLOYEES0;

SELECT EMP_ID, EMP_LAST_NAME, SALARY, BONUS
FROM EMPLOYEES0;

-- Calculating total annual compensation by adding salary and bonus together. To demonstrate that Null + x = Null.

SELECT
    EMP_ID,
    EMP_LAST_NAME,
    SALARY,
    BONUS,
    SALARY + BONUS AS TOTAL_COMPENSATION
FROM EMPLOYEES0;

-- 65,000 + Null = Null
-- WORKAROUND: is to replace nulls with ISNULL function in the query:

SELECT
    EMP_ID,
    EMP_LAST_NAME,
    SALARY,
    BONUS,
    SALARY + ISNULL(BONUS, 0) AS TOTAL_COMPENSATION
FROM EMPLOYEES0;

-- In this case ISNULL(BONUS, 0) will replace BONUS with 0 since BONUS is NULL.

-- Now that I have show the necessity for constraints lets reimpliment this table with constraints.

DROP TABLE EMPLOYEES0;

-- PERMANENT SOLUTION:

CREATE TABLE EMPLOYEES1
(
    EMP_ID INT,
    EMP_LAST_NAME VARCHAR(50) NOT NULL,
    SALARY DECIMAL(12,2) NOT NULL,
    BONUS DECIMAL(12,2) NOT NULL,
    CONSTRAINT EMPLOYEES1_PK PRIMARY KEY (EMP_ID)
);

-- We did not have to specify NOT NULL for the EMP_ID column because it is the primary key and already cannot contain NULLS. This primary key constraint also ensure that EMP_ID column will have unique values.

-- NOT NULL Constraints in SQL Server must always be specified in-line not out-of-line, like we did for the PRIMARY KEY

INSERT INTO EMPLOYEES1 (EMP_ID, EMP_LAST_NAME, SALARY, BONUS) VALUES (1, 'Jones', 60000, 800);
INSERT INTO EMPLOYEES1 (EMP_ID, EMP_LAST_NAME, SALARY, BONUS) VALUES (2, 'Richardson', 65000, null);

-- The above queries will throw an error due to our NOT NULL constraint on BONUS column.

INSERT INTO EMPLOYEES1 (EMP_ID, EMP_LAST_NAME, SALARY, BONUS) VALUES (2, 'Richardson', 65000, 0);

SELECT *
FROM EMPLOYEES1;

--------------------------------------------
-----HANDLING NULLS WHEN FILTERING DATA-----
--------------------------------------------

CREATE TABLE PRODUCTS99
(
    PROD_ID INT,
    PRODUCT_NAME VARCHAR(50),
    MANUFACTURER_COUNTRY VARCHAR(50),
    CONSTRAINT PRODUCTS99_PROD_ID_PK PRIMARY KEY (PROD_ID)
);

INSERT INTO PRODUCTS99 (PROD_ID, PRODUCT_NAME, MANUFACTURER_COUNTRY) VALUES (1, 'E34 MP3 PLATER', 'Japan');
INSERT INTO PRODUCTS99 (PROD_ID, PRODUCT_NAME, MANUFACTURER_COUNTRY) VALUES (2, '34S2 SMART PHONE', 'Japan');
INSERT INTO PRODUCTS99 (PROD_ID, PRODUCT_NAME, MANUFACTURER_COUNTRY) VALUES (3, 'R12 SMART PHONE', 'USA');
INSERT INTO PRODUCTS99 (PROD_ID, PRODUCT_NAME, MANUFACTURER_COUNTRY) VALUES (4, '808 FITNESS TRACKER', 'USA');
INSERT INTO PRODUCTS99 (PROD_ID, PRODUCT_NAME, MANUFACTURER_COUNTRY) VALUES (5, 'R4 TABLET', NULL);

-- Query with a filter

SELECT *
FROM PRODUCTS99
WHERE MANUFACTURER_COUNTRY = 'Japan';

SELECT *
FROM PRODUCTS99
WHERE MANUFACTURER_COUNTRY != 'Japan'; -- <> OR != means NOT EQUALS, but this will not return NULL values

SELECT *
FROM PRODUCTS99
WHERE MANUFACTURER_COUNTRY != 'Japan' OR MANUFACTURER_COUNTRY IS NULL;

-- Aggregate functions such as COUNT, MAX, MIN ignore nulls except for COUNT(*):

SELECT COUNT(MANUFACTURER_COUNTRY)
FROM PRODUCTS99;

-- This only returns 4 because it doesnt count the row with a NULL value.

DROP TABLE EMPLOYEES1;
DROP TABLE CLIENTS1;
DROP TABLE PRODUCTS99;